---
layout: post
title:  "用python写的文件上传下载软件2010年12月16日弄的累，不过一劳永逸的哈哈2010-12-16"
date:   2011-03-10 10:19:34
categories: python
tags:
---

* content
{:toc}

用python写的文件上传下载软件 登陆用的是主动模式 问题1：批量上传还没做好 (已经修改)问题2：下载还没改造好，会比较文件大小，但只修改了几个字符则会认为文件大小相同而不下载 2010年12月16日星期五 上午 11：07  修改好上传文件比较大小相同后不上传文件的问题，并且有进度显示。 2010年12月20日星期一 下午1：56 修改了登陆为一次登陆，上传多个文件后退出登陆。     # -*- coding: utf-8 -*- from ftplib import FTP import sys import os.path import string,datetime,time import socket    class MyFTP(FTP):     '''''     conncet to FTP Server     '''     def ConnectFTP(self,remoteip,remoteport,loginname,loginpassword):         ftp=MyFTP()         try:             ftp.connect(remoteip,remoteport)         except:             return (0,'conncet failed')         else:             try:                 ftp.set_pasv(0)                 ftp.login(loginname,loginpassword)             except:                 return (0,'login failed')             else:                 return (1,ftp)           def download(self,res,remotePath,localPath):         #connect to the FTP Server and check the return         #res = self.ConnectFTP(remoteHost,remotePort,loginname,loginpassword)         if(res[0]!=1):             print res[1]             sys.exit()                   #change the remote directory and get the remote file size         ftp=res[1]         #ftp.set_pasv(0)         dires = self.splitpath(remotePath)         if dires[0]:             ftp.cwd(dires[0])         remotefile=dires[1]         print dires[0]+' '+ dires[1]         fsize=ftp.size(remotefile)         if fsize==0 :             return                   #check local file isn't exists and get the local file size         lsize=0L         if os.path.exists(localPath):             lsize=os.stat(localPath).st_size                       if lsize >= fsize:             print 'local file is bigger or equal remote file'             return         blocksize=1024         cmpsize=lsize         ftp.voidcmd('TYPE I')         conn = ftp.transfercmd('RETR '+remotefile,lsize)         lwrite=open(localPath,'ab')         while True:             data=conn.recv(blocksize)             if not data:                 break             lwrite.write(data)             cmpsize+=len(data)             print '\b'*30,'download process:%.2f%%'%(float(cmpsize)/fsize*100),         lwrite.close()         ftp.voidcmd('NOOP')         ftp.voidresp()         conn.close()         ftp.quit()           def upload(self,res,remotepath,localpath,callback=None):         if not os.path.exists(localpath):             print "Local file doesn't exists"             return         self.set_debuglevel(2)                  if res[0]!=1:             print res[1]             sys.exit()         ftp=res[1]         remote=self.splitpath(remotepath)         ftp.cwd(remote[0])          rsize=0L         try:             rsize=ftp.size(remote[1])         except:             pass         if (rsize==None):             rsize=0L         lsize=os.stat(localpath).st_size         if (lsize):             localf=open(localpath,'rb')             ftp.voidcmd('TYPE I')             if (rsize==None):                 rsize = 0L                 datasock,esize=ftp.ntransfercmd("APPE "+remote[1],0)             else:                 datasock,esize=ftp.ntransfercmd("STOR "+remote[1],0)             cmpsize=0             while True:                 buf=localf.read(1024)                 if not len(buf):                     print '\rno data break'                     break                 datasock.sendall(buf)                 if callback:                     callback(buf)                 cmpsize+=len(buf)                 print '\b'*30,'uploading %.2f%%'%(float(cmpsize)/lsize*100)                 if cmpsize==lsize:                     print remote[0]+remote[1]+'  文件上传完成'                     break             datasock.close()             #print 'close data handle'             localf.close()             #print 'close local file handle'             ftp.voidcmd('NOOP')             #print 'keep alive cmd success'             ftp.voidresp()             #print 'No loop cmd'     def closeftp(self,ftp):         ftp.quit()         print '现在退出FTP!'               def splitpath(self,remotepath):         position=remotepath.rfind('/')         return (remotepath[:position+1],remotepath[position+1:])     def upload_files(self,remotehost,remoteport,loginname,loginpassword,remotepath,localpath,callback=None):         if not os.path.exists(localpath):             print "Local file doesn't exists"             return         self.set_debuglevel(2)         res=self.ConnectFTP(remotehost,remoteport,loginname,loginpassword)         if not os.path.isdir(remotepath):             return         localnames = os.listdir(localdir)         ftp.cwd(remotedir)         for item in localnames:             src = os.path.join(localdir, item)             if os.path.isdir(src):                 try:                     ftp.mkd(item)                 except:                     self.debug_print('目录已经存在 %s' %item)                 self.upload_files(src, item)             else:                 self.upload_file(src, item)         #ftp.cwd('..')      def debug_print(s):         print (s)           if __name__=='__main__':     lf = MyFTP()     res=lf.ConnectFTP('***.***.***.***','21','username','password')     filename1 = 'zhpj.php'     filename2 = 'templates/newtheme/zhpj.html'     filename3 = 'zhpj_ajax.php'     filename4 = 'templates/newtheme/inc/pj.php'     filename5 = 'templates/newtheme/inc/repj.php'      osdir = '/media/4C88-A7AD/work/yidaba/shop/'     ftpdir = '/ydbv10/shop/index/shop/'      lf.upload(res,ftpdir+filename1,osdir+filename1)     lf.upload(res,ftpdir+filename2,osdir+filename2)     lf.upload(res,ftpdir+filename3,osdir+filename3)     lf.upload(res,ftpdir+filename4,osdir+filename4)     lf.upload(res,ftpdir+filename5,osdir+filename5)     lf.closeftp(res[1])     #lf.upload_files('***.***.***.***','21','username','password',ftpdir,osdir) #暂时先不能用批量更新目录功能，可能会影响别人共同开发
        
